/** * Copyright (c) Meta Platforms, Inc. and affiliates. * * This source code is licensed under the MIT license found in the * LICENSE file in the root directory of this source tree. * * @emails react-core */  let createP// These tests are intentionally testing the private injection interface.// The public API surface of this is covered by other tests so// if `EventPluginREventPluginRegistry = require('react-native-renderer/src/legacy-events/EventPluginRegistry');createPlugin = function (properties) {  return Object.assign({extractEvents: function () {}}, properties);};  });  it('should be able to inject ordering before plugins', () => {const OnePlugin = createPlugin();const TwoPlugin = createPlugin();const ThreePlugin = createPlugin();EventPluginRegistry.injectEventPluginOrder(['one', 'two',: OnePlugin,  two: TwoPlugin,});Event});expect(EventPluginRegistry.plugins.length).toBe(3);expect(EventPluginRegistry.plugins[0]).toBe(OnePlugin);expect(EventPluginRegistry.plugins[1]).toBe(TwoPlugin);expect(EventPluginRegistry.plugins[const OnePlugin = createPlugin();const TwoPlugin = createPlugin();const ThreePlugin = createPlugin();EventPluginRegistry.injectEventPluginsByName({  one: OnePlugin,  two: TwoPlugin,});EventPluginRegistry.injectEventPluginOrder(['one', 'two', 'three']);Eve});expect(EventPluginRegistry.plugins.length).toBe(3);expect(EventPluginRegistry.plugins[0]).toBe(OnePlugin);expect(EventPluginRegistry.plugins[1]).toBe(TwoPlugin);expect(EventPluginRegistry.plugins[2]).toBe(ThreePlugin);  });const TwoPlugin = createPlugin();const ThreePlugin = createPlugin();EventPluginRegistry.injectEventPluginsByName({  one: OnePlugin,  three: ThreePlugin,EventPluginRegistry.injectEventPluginOrder(['one', 'two', 'three']);EventPluginRegistry.injectEventPluginsByName({  two: TwoPlugin,  three: ThreePlugin,});expect(EventPluginRegistry.plugins.length).toBe(3);expect(EventPluginRegistry.plugins[0]).toBe(OnePlugin);expect(EventPluginRegistry.plugins[1]).toBe(TwoPlugin);expconst BadPlugin = {};EventPluginRegistry.injectEventPluginOrder(['bad']);expect(function () {  EventPluginRegistry.injectEventPluginsByName({bad: BadPlugin,  });}).to'method, but `bad` does not.',);  });  it('should throw if plugin does not exist in ordering', () => {const OnePlugin = createPlugin();  EventPluginRegistry.injectEventPluginsByName({one: OnePlugin,random: RandomPlugin,  });}).toThrowError(  'EventPluginRegistry: Cannot inject event plugins that do not exist ' +'in the plugin ordering, `random`.',);  }  EventPluginRegistry.injectEventPluginOrder(pluginOrdering);}).toThrowError(  'EventPluginRegistry: Cannot inject event plugin ordering more than ' +'once. You are likely trying to load more than one copy of React.',);const OnePlugin = createPlugin();const TwoPlugin = cre}).toThrowError('the same name, `same`.',);  });  it('should publish registration names of injected plugins', () => {const OnePlugin = createPlugin({  eventTypes: {click: {registrationName: 'onClick'},focus: {registrationName: 'onFocus'},  },});  eventTypes: {magic: {  phasedRegistrationNames: {captured: 'onMagicCapture',},  },});EventPluginRegistry.injectEventPluginsByName({one: OnePlugin});EventPluginRegistry.injectEventPluginOrder(['one', 'two']);expect(  Object.keys(EventPluginRegistry.registrationNameModules).length,).toBe(2);expect(EventPluginRegistry.registrationNameModules.onClick).toBe(OnePlugin);expect(EventPluginRegistry.registrationNameModules.onFocus).toBe(OnePlugin);EventPluginRegistry.injectEventPluginsByName({two: TwoPlugin});expect(  Object.keys(EventPluginRegistry.registrationNameModules).length,).toB  TwoPlugin,);  TwoPlugin,  });  it('should throw if multiple registration names collide', () => {const OnePlugin = createPlugin({  eventTypes: {photoCapture: {registrationName: 'onPhotoCapture'},  },});constphoto: {  phasedRegistrationNames: {bubbled: 'onPhotoBubble',  },  },});EventPluginRegistry.injectEventPluginsByName({  one: OnePlugin,  two: TwoPlugin,});expect(function () {  EventPluginRegistry.injectEventPluginOrder(['one', 'two']);}).to'registration name, `onPhotoCapture`.',);  });  it('should throw if an invalid event is published', () => {const OnePlugin = createPlugin({  eventTypes: {badEvent: {  /* missing configuration */},  },});EventPluginRegistry.injectEventPluginsByName({one: OnePlugin});expect(function () {  EventPluginRegistry.injectEventPluginOrder(['one']);}).toThrowError(  'EventPluginRegistry: Failed to publish event `badEvent` for plugin ' +'`one`.',);  });});