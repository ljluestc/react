/** * Copyright (c) Meta Platforms, Inc. and affiliates. * * This source code is licensed under the MIT license found in the * LICENSE file in the root directory of this source tree. * * @flow */import {  UIManager,  getNodeFromPublicInstance,  getNativeTagFromPublicInstance,} from 'react-native/Libraries/ReactPrivate/ReactNativePrivateInterface';import {  findHostInstance,  findHostInstanceWithWarning,} from 'react-reconciler/src/ReactFiberReconciler';import ReactSharedInternals from 'shared/ReactSharedInternals';  componentOrHandle: ?(ElementRef<TElementType> | number),): ?ElementRef<HostComponent<mixed>> {  if (__DEV__) {const owner = ReactCurrentOwner.current;if (owner !== null && owner.stateNode !== null) {  if (!owner.stateNode._warnedAboutRefsInRender) {  '%s is accessing findNodeHandle inside its render(). ' +'never access something that requires stale data from the previous ' +'render, such as refs. Move this logic to componentDidMount and ' +'componentDidUpdate instead.',  getComponentNameFromType(owner.type) || 'A component',);  }  owner.stateNode._warnedAboutRefsInRender = true;}  }  if (componentOrHandle == null) {return null;  }  // For compatibility with Fabric instances  if (componentOrHandle.canonical &&componentOrHandle.canonical.publicInstance  ) {// $FlowExpectedError[incompatible-return] Can't refine componentOrHandle as a Fabric instanceret  if (componentOrHandle._nativeTag) {// $FlowFixMe[incompatible-exact] Necessary when running Flow on Fabric//let hostInstance;  if (__DEV__) {hos  'findHostInstance_DEPRECATED',);  } else {hostInstance = findHostInstance(componentOrHandle);  }  // findHostInstance handles legacy vs. Fabric differences correctly  // $FlowFixMe[incompatible-exact] we need to fix the definition of `HostComponent` to use NativeMethods as an interface, not as a type.  // $FlowFixMe[incompatible-return]  r  if (__DEV__) {const owner = ReactCurrentOwner.current;if (owner !== null && owner.stateNode !== null) {  if (!owner.stateNode._warnedAboutRefsInRender) {console.error(  ''never access something that requires stale data from the previous ' +'render, such as refs. Move this logic to componentDidMount and ' +'componentDidUpdate instead.',  getComponentNameFromType(owner.type) || 'A component',);  }  owner.stateNode._warnedAboutRefsInRender = true;}  }  if (componentOrHandle == null) {ret// Already a node handlereturn componentOrHandle;  }  // For compatibility with legacy renderer instances  if (componentOrHandle._nativeTag) {r  if (componentOrHandle.canonical != null &&componentOrHandle.canonical.nativeTag != null  ) {return componentOrHandle.canonical.nativeTag;  }  // For compatibility with Fabric public instances  const nativeTag = getNativeTagFromPublicInstance(componentOrHandle);  if (nativeTag) {return nativeTag;  }  let hostInstance;  if (__DEV__) {hostInstance = findHostInstanceWithWarning(  componentOrHandle,  '  } else {hostInstance = findHostInstance(componentOrHandle);  }  }  // $FlowFixMe[incompatible-type] For compatibility with legacy renderer instances  if (hostInstance._nativeTag != null) {ret  return getNativeTagFromPublicInstance(hostInstance);}export function dispatchCommand(  handle: any,  c) {  const nativeTag =handle._nativeTag != null  ?  if (nativeTag == null) {if (__DEV__) {  console.error("dispatchCommand was called with a ref that isn't a " +  'native component. Use React.forwardRef to get access to the underlying native component',  );}  }  const node = getNodeFromPublicInstance(handle);  if (node != null) {nativeFabricUIManager.dispatchCommand(node, command, args);  } else {UIManager.dispatchViewManagerCommand(nativeTag, command, args);  }  const nativeTag =handle._nativeTag != null  ? handle._nativeTag  : getNativeTagFromPublicInstance(handle);  if (nativeTag == null) {if (__DEV__) {  console.error("sendAccessibilityEvent was called with a ref that isn't a " +  '}return;  }nativeFabricUIManager.sendAccessibilityEvent(node, eventType);  } else {legacySendAccessibilityEvent(nativeTag, eventType);  }  internalInstanceHandle: mixed,): ?Node { internalInstanceHandle &&// $FlowExpectedError[incompatible-return]internalInstanceHandle.stateNode &&// $FlowExpectedError[incompatible-use]internalInstanceHandle.stateNode.node  );}