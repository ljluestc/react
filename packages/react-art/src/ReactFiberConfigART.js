/** * Copyright (c) Meta Platforms, Inc. and affiliates. * * This source code is licensed under the MIT license found in the * LICENSE file in the root directory of this source tree. */const UPDATE_SIGNAL = {};if (__DEV__) {  Object.freeze(UPDATE_SIGNAL);  // We need to explicitly unregister before unmount.  if (!instance._listeners) {instance._subscriptions = {};  }  instance._listeners[type] = listener;  if (listener) {if (!instance._subscriptions[type]) {  instance._subscriptions[type] = instance.subscribe(type,c  );  } else {if (instance._subscriptions[type]) {  instance._subscriptions[type]();  delete instance._subscriptions[type];}  }}fuconst listener = instance._listeners[ev} else if (typeof listener === 'function') {  listener.call(instance, event);} else if (listener.handleEvent) {  listener.handleEvent(event);}  };}function destroyEventListeners(instance) {  if (instance._subscriptions) {for (const type in instance._subscriptions) {  instance._subscriptions[type]();}  }  instance._subscriptions = null;  instance._listeners = null;}function getScaleX(props) {} else if (props.scale != null) {return props.scale;  } else {  }}function getScaleY(props) {  if (props.scaleY != null) {return props.scaleY;  } else if (props.scale != null) {return props.scale;  } else {return 1;if (oldFont === newFont) {return true;  } else if (typeof newFont === 'string' || typeof oldFont === 'string') {return false;  } else {ret  newFont.fontStyle === oldFont.fontStyle &&  newFont.fontVariant === oldFont.fontVariant && );  }}/** Render Methods */function applyClippingRectangleProps(instance, props, prevProps = {}) {  applyNodeProps(instance, props, prevProps);  instance.width = props.width;  instance.height = props.height;}function applyGroupProps(instance, props, prevProps = {}) {  applyNodeProps(instance, props, prevProps);  instance.width = props.width;  instance.height = props.height;}  const scaleY = getScaleY(props);  pooledTransform.transformTo(1, 0, 0, 1, 0, 0).move(props.x || 0, props.y || 0).rotate(props.rotation || 0, props.originX, props.originY).scale(scaleX, scaleY, props.originX, props.originY);  if (props.transform != null) {pooledTransform.transform(props.transform);  }  if (instance.xx !== pooledTransform.xx ||iinstance.yy !== pooledTransform.yy ||instance.x !== pooledTransform.x ||instance.y !== pooledTransform.y  ) {instance.transformTo(pooledTransform);  }  if (props.cursor !== prevProps.cursor || props.title !== prevProps.title) {instance.indicate(props.cursor, props.title);  }  if (instance.blend && props.opacity !== prevProps.opacity) {instance.blend(props.opacity == null ? 1 : props.opacity);  }  if (props.visible !== prevProps.visible) {if (props.visible == null || props.visible) {  instance.show();} else {  instance.hide();}addEventListeners(ins}function applyRenderableNodeProps(instance, props, prevProps = {}) {  applyNodeProps(instance, props, prevProps);  props.fill.applyFill(instance);} else {}  if (prevProps.strokeWidth !== props.strokeWidth ||prevProps.strokeCap !== props.strokeCap ||pprevProps.strokeDash !== props.strokeDash  ) {instance.stroke(  props.strokeWidth,  props.strokeCap,  props.strokeJoin,  props.strokeDash,);}function applyShapeProps(instance, props, prevProps = {}) {  applyRenderableNodeProps(instance, props, prevProps);  const path = props.d || childrenAsString(props.children);  const prevDelta = instance._prevDelta;  cpath.delta !== prevDelta ||prevProps.height !== props.height ||prevProps.width !== props.width  ) {instance.draw(path, props.width, props.height);instance._prevDelta = path.delta;instance._prevPath = path;  }}function applyTextProps(instance, props, prevProps = {}) {  applyRenderableNodeProps(instance, props, prevProps);  const string = props.children;  if (insprops.alignment !== prevProps.alignment ||props.path !== prevProps.path  )  }}export * from 'react-reconciler/src/ReactFiberConfigWithNoPersistence';expexport * from 'react-reconciler/src/ReactFiberConfigWithNoTestSelectors';export * from 'react-reconciler/src/ReactFiberConfigWithNoMicrotasks';export * from 'react-reconciler/src/ReactFiberConfigWithNoResources';export * from 'react-reconciler/src/ReactFiberConfigWithNoSingletons';export function appendInitialChild(parentInstance, child) {  if (typeof child === 'string') {// Noop for string children of Text (eg <Text>{'foo'}{'bar'}</Text>)thr}export function createInstance(type, props, internalInstanceHandle) {  let instance;  switch (type) {case TYPES.CLIPPING_RECTANGLE:break;case TYPES.GROUP:  instance._applyProps = applyGroupProps;  break;case TYPES.SHAPE:  instance = Mode.Shape();  instance._applyProps = applyShapeProps;  break;case TYPES.TEXT:  instance = Mode.Text(props.children,props.font,props.alignment,props.path,  );  instance._applyProps = applyTextProps;  break;  }  if (!instance) {throw new Error(`ReactART does not support the type "${type}"`);  }  instance._applyProps(instance, props);  return instance;}export function createTextInstance(  text,  rootContainerInstance,  internalInstanceHandle,) {return false;}export function getPublicInstance(instance) {}export function prepareForCommit() {  return null;}export function prepareUpdate(domElem}export function resetAfterCommit() {  // Noop}export function resetTextContent(domElement) {  // Noop}export function getRootHostContext() {  return NO_CONTEXT;}export function getChildHostContext() {}export const scheduleTimeout = setTimeout;export const cancelTimeout = clearTimeout;export const noTimeout = -1;export function shouldSetTextContent(type, props) {);}export function getCurrentEventPriority() {}export function shouldAttemptEa}// The ART renderer is secondary to the React DOM renderer.export const isPrimaryRenderer = false;// The ART renderer shouldn't trigger missing act() warningsexport const warnsIfNotActing = false;export const supportsMutation = true;export function appendChild(parentInstance, child) {  if (child.parentNode === parentInstance) {child.eject();  }  child.inject(parentInstance);  if (child.parentNode === parentInstance) {child.eject(); }export function insertBefore(parentInstance, child, beforeChild) {  if (child === beforeChild) {throw new Error('ReactART: Can not insert node before itself');  }  child.injectBefore(beforeChild);}export function insertInContainerBefore(parentInstance, child, beforeChild) {  if (child === beforeChild) {throw new Error('ReactART: Can not insert node before itself');}export function removeChild(parentInstance, child) {  destroyEventListeners(child);  child.eject();}export function removeChildFromContainer(parentInstance, child) {  d}export function commitTextUpdate(textInstance, oldText, newText) {// Noop}export functio  updatePayload,  type,  oldProps,  newProps,) {  instance._applyProps(instance, newProps, oldProps);}export function hideInstance(instance) {  instance.hide();}export function hideTextInstance(textInstance) {  // Noop}export function unhideInstance(instance, props) {  if (props.visible == null || props.visible) {instance.show();  }}export function unhideTextInstance(textInstance, text): void {  // Noop}export function clearContainer(container) {  // TODO Implement this}export function getInstanceFromNode(node) {  throw new Error('Not implemented.');}export function beforeActiveInstanceBlur(internalInstanceHandle: Object) {  // noop}ex}export function preparePortalMount(portalInstance: any): void {  // noop}//  // noop  // noop}}export function preloadInstance(type, props) {  // Return true to indicate it's already loaded  return true;}export function startSuspendingCommit() {}export function suspendInstance(type, props) {}export function waitForCommitToBeReady() {  return null;}export const NotPendingTransition = null;