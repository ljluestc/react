/** * Copyright (c) Meta Platforms, Inc. and affiliates. * * This source code is licensed under the MIT license found in the * LICENSE file in the root directory of this source tree. * * @emails react-core */import ARTCurrentMode // Since theyimport Rectangle from 'react-arjest.resetModules();const ReactDOM = require('react-dom');const ReactTestUtils = require('react-dom/test-utils');// Isolate test renderer.jest.resetModules();const ReactTestRenderer = require('react-test-renderer');// Isolate the noop rendererjest.resetModules();const ReactNoop = require('react-noop-renderer');const Scheduler = require('schedulerlet Surface;let TestComponent;let waitFor;const Missing = {};function testDOMNodeStructure(domNode, expectedStructure) {  expect(domNode).toBeDefined();  expect(domNode.nodeName).toBe(expectedStructure.nodeNif (!expectedStructure.hasOwnProperty(prop)) {  continue;}  if (expectedStructure[prop] === Missing) {expect(domNode.hasAttribute(prop)).toBe(false);  } else {expect(domNode.getAttribute(prop)).toBe}  }  if (expectedStructure.children) {expectedStructure.});}describe('ReactARTcontainer = document.createElement('div');document.body.appendChild(container);ARTCurrentMode.setCurrent(ARTSVGMode);Group = ReactART.Group;Shape = ReactART.Shape;Surface = ReactART.Surface;({waitFor} = require('internal-test-utils'));TestComponent = class extends React.Component {  group = React.createRef();  render() {const a = (  <Shaped="M0,0l50,0l0,50l-50,0z"fill={new ReactART.LinearGradient(['black', 'white'])}key="a"width={50}height={50}x={50}y={50}opacity={0.1}  />);const b = (  <Shapefill="#3C5A99"key="b"sy={50}title="This is aM64.564,38.583H54l0.008-5.834c0-3.035,0.293-4.666,4.657-4.666h5.833V16.429h-9.33c-11.213,0-15.159,5.654-15.159,15.16v6.994h-6.99v11.652h6.99v33.815H54V50.235h9);const c = <Group key="c" />;return (<Group ref={this.group}>  {this.props.flipped ? [b, a, c] : [a, b, c]}</Group>);};  });  afterEach(() => {container = null;  });  it('should have the correct lifecycle state', () => {let instance = <TestComponent />;instance = ReactTestUtils.renderIntoDocument(instance);const group = instance.group.current;// Duck type test for an ART groupexpect(typeof group.indicate).toBe('function');  });  it('should render a reasonable SVG structure in SVG mode', () => {let instance = <TestComponent />;instance = ReactTestUtils.renderIntoDocument(instance);const expectedStructure = {  nodeName: 'svg',  width: '150',  {nodeName: 'defs'},{  nodeName: 'g',  children: [{  nodeName: 'defs',  children: [{nodeName: 'linearGradient'}],},{nodeName: 'path'},{nodeName: 'path'},{nodeName: 'g'},  ],},  testDOMNodeStructure(realNodconst instance = ReactDOM.render(  <TestComponent flipped={false} />,  container,);const expectedStructure = {  nodeName: 'svg',  children: [{nodeName: 'defs'},{  nodeName: 'g',  chi{nodeName: 'path', opacity: '0.1'},{nodeName: 'path', opacity: Missing},{nodeName: 'g'},  ],  ],};const realNode = ReactDOM.findDOMNode(instance);testDOMNodeStructure(realNode, expectedStructure);ReactDOM.render(<TestComponent flipped={true} />, container);const expectedNewStructure = {  nodeName: 'svg',  children: [{nodeName: 'defs'},{  children: [{nodeName: 'defs'},{nodeName: 'path', opacity: Missing},{nodeName: 'g'},  ],},  ],};testDOMNodeStructure(realNode, expectedNewStructure);  });  it('should be able to reorder many components', () => {class Component extends React.Component {  render() {const chars = this.props.chars.split('');return (  <Surface>{chars.map(text => (  <Shape key={text} title={text} />))}  </Surface>);  }}// Mini multi-child stress test: lots of reorders, some adds, some removes.const before = 'abcdefghijklmnopqrst';coexpect(realNode.textContent).toBe(before);instance = ReactDOM.render(<Component chars={after} />, container);expect(realNode.textContent).toBe(after);ReactDOM.unmountComponentAtNode(container);  });  render() {return <Shape />;  }  componentDidMount() {mounted = true;<Surface><Group>  <CustomShape /></Group>  </Surface>,);expect(mounted).toBe(true);  });  it('resolves refs before componentDidMount', () => {class CustomShape extends React.Component {  render() {return <Shape />;  }}let ref = null;class Outer extends React.Component {  test = React.createRef();  componentDidMount() {rereturn (  <Surface>  <CustomShape ref={this.test} />  </Surface>);  }}ReactTestUtils.renderIntoDocument(<Outer />);expect(ref.constructor).toBe(CustomShape);  });  it('resolves refs before componentDidUpdate', () => {class CustomShape extends React.Component {  render() {return <Shape />;  }}let ref = {};class Outer extends React.Component {  test = React.createRef();  componentDidMount() {ref = this.test.current;  }  componentDidUpdate() {rereturn (  <Su  {this.props.mountCustomShape && <CustomShape ref={this.test} />}</Group>  </Surface>);  }}ReactDOM.render(<Outer />, container);expect(ref).toBe(null);ReactDOM.render(<Outer mountCustomShape={true} />, container);expect(ref.constructor).toBe(CustomShape);  });  it('adds and updates event handlers', () => {function render(onClick) {<Shape onClick={onClick} /></Surface>,container,}function doClick(instance) {  const path = ReactDOM.findDOMNode(instance).querySelector('path');  path.dispatchEvent(new MouseEvent('click', {}),  );let instance = render(onClick1);doCliinstance = render(onClick2);doClick(instance);  });  // @gate forceConcurrentByDefaultForTesting  it('can concurrently render with a "primary" renderer while sharing context', async () => {const CurrentRendererContext = React.createContext(null);function Yield(props) {  S}let ops = [];function LogCurrentRenderer() {  return (<ops.push(currentRenderer);return null;  }}</CurrentRendererContext.Consumer>  );}// Using test renderer instead of the DOM renderer here because async// testing APIs for the DOM renderer don't exist.ReactNoop.render(  <Cu<Yield value="B" /><LogCurrentRenderer /><Yield value="C" />  </CurrentRendererContext.Provider>,);await waitFor(['A']);ReactDOM.render( <CurrentRendere</CurrentRendererContext.Provider>  </Surface>,);expect(ops).toEqual([null, 'ART']);ops = [];await waitFor(['B', 'C']);expect(ops).toEqual(['Test']);  }  it('should generate a <Shape> with props for drawing the Circle', () => {const circle = ReactTestRenderer.create(  <Circle radius={10} stroke="green" strokeWidth={3} fill="blue" />,);expect(circle.toJSON()).toMatchSnapshot();  });  it('should warn if radius is missing on a Circle component', () => {expect(() =>  ReactTestRenderer.create(<Circle stroke="green" strokeWidth={3} fill="blue" />,'Warning: Failed prop type: The prop `radius` is marked as required in `Circle`, ' +'but its value is `undefined`.' +'\nin  });  it('should generate a <Shape> with props for drawing the Rectangle', () => {const rectangle = ReactTestRenderer.create(  <Rectangle width={50} height={50} stroke="green" fill="blue" />,);expect(rectangle.toJSON()).toMatchSnapshot();<Rectangle expect(rectangle.toJSON()).toMatchSnapshot();  });  it('should generate<Rectangle height={-50} width={50} />,);expconst rectangle = ReactTestRenderer.create(  <Rectangle radiusTopLeft={-25} width={50} height={50} />,);  });  it('should generate a <Shape> with a radius property of 0 when top right radius prop is negative', () => {const rectangle = ReactTestRenderer.create(  <Rectangle radiusTopRight={-25} width={50} height={50} />,);expect(rectangle.toJSON()).toMatchSnapshot();  });  it('should generate a <Shape> with a radius property of 0 when bottom right radius prop is negative', () => {const rectangle = ReactTestRenderer.create(  <Rectangle radiusBottomRight={-30} width={50} height={50} />,);expect(rectangle.toJSON()).toMatchSnapshot();  });  it('should generate a <Shape> with a radius property of 0 when bottom left radius prop is negative', () => {const rectangle = ReactTestRenderer.create(  <Rectangle radiusBottomLeft={-25} width={50} height={50} />,);expecconst rectangle = ReactTestRenderer.create(  <RectangleradiusTopRight={25}radiusTopLeft={26}width={50}height={40}  />,);eexpect(() =>  ReactTestRenderer.create(<Rectangle stroke="green" fill="blue" />)  'Warning: Failed prop type: The prop `width` is marked as required in `Rectangle`, ' +'but its value is `undefined`.' +'\nin Rectangle (at **)',  'Warning: Failed prop type: The prop `height` is marked as required in `Rectangle`, ' +'but its value is `undefined`.' +'  });  it('should generate a <Shape> with props for drawing the Wedge', () => {const wedge = ReactTestRenderer.create(  <Wedge outerRadius={50} startAngle={0} endAngle={360} fill="blue" />,);  });  it('should return null if startAngle equals to endAngle on Wedge', () => {const wedge = ReactTestRenderer.create(  <Wedge outerRadius={50} startAngle={0} endAngle={0} fill="blue" />,);expecexpect(() => ReactTestRenderer.create(<Wedge fill="blue" />)).toErrorDev([  'Warning: Failed prop type: The prop `outerRadius` is marked as required in `Wedge`, ' +'but its value is `undefined`.' +  'Warning: Failed prop type: The prop `startAngle` is marked as required in `Wedge`, ' +'but its value is `undefined`.' +'\nin Wedge (at **)', '\nin Wedge (at **)',]);  });});