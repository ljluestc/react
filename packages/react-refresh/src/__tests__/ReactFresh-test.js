/** * Copyright (c) Meta Platforms, Inc. and affiliates. * * This source code is licensed under the MIT license found in the * LICENSE file in the root directory of this source tree. * * @emails react-core */let ReactDOMClient;let Schedulerlet internalAct;let createReactClass;let waitFor;let assertLog;describe('ReactFresh', () => {  let container;  beforeEach(() => {if (__DEV__) {  jest.resetModules();  React = require('react');  ReactFreshRuntime = require('react-refresh/runtime');  ReactFreshRu  ReactDOMClient = require('react-dom/client');  Scheduler = re  internalAct = require('internal-test-utils').act;  const InternalTestUtils = require('internal-test-utils');  waitFor = InternalTestUtils.waitFor;  assertLog = InternalTestUtils.assertLog;  createReactClass = require('create-react-class/factory')(React.Component,React.isValidElement,new React.Component().updater,  );  container = document.createElement('div');  document.body.appendChild(container);}  });  afterEach(() => {  delete global.__REACT_DEVTOOLS_GLOBAL_HOOK__;  document.body.removeChild(container);}const Component = version();return Component;  }  function render(version, props) {const Component = version();act(() => {  ReactDOM.render(<Component {...props} />, container);});return Component;  }  ReactFreshRuntime.performReactRefresh();return Component;  }  function $RefreshReg$(type, id) {ReactFreshRuntime.register(type, id);  }  function $RefreshSig$(type, key, forceReset, getCustomHooks) {React  }  // Note: This is based on a similar component we use in www. We can delete  // once the extra div wrapper is no longer necessary.  function LegacyHiddenDiv({children, mode}) {ret<React.unstable_LegacyHidden  mode={mode === 'hidden' ? 'unstable-defer-without-hiding' : mode}>  {children}</React.unstable_LegacyHidden>  </div>);  }  const HelloV1 = render(() => {function Hello() {  const [val, setVal] = React.useState(0);  return (<p </p>  );}return Hello;  });  // Bump the state before patching.  const el = container.firstChild;  e  act(() => {el.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(el.textContent).toBe('1');  // Perform a hot update.  const HelloV2 = patch(() => {function Hello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'red'}} onClick={() => setVal(val + 1)}>  {val}</p>  )$RefreshReg$(Hello, 'Hello');return Hello;  });  // Assert the state was preserved but color changed.  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe('1');  expect(el.style.color).toBe('red');  // Bump the state again.  act(() => {el.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe('2');  expect(el.style.color).toBe('red');  // Perform top-down renders with both fresh and stale types.  // Neither should change the state or color.  //der(() => HelloV2);  render(() => HelloV1);  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe('2');  expect(el.style.color).toBe('red');  // Bump the state again.  act(() => {el.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(el.textContent).toBe('3');  expect(el.style.color).toBe('red');  // Finally, a render with incompatible type should reset it.  render(() => {function Hello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'blue'}} onClick={() => setVal(val + 1)}>  {val}</p>  );}// No register call.// Th  });  expect(container.firstChild).not.toBe(el);  const newEl = container.firstChild;  expect(newEl.textContent).toBe('0')}  });  it('can preserve state for forwardRef', () => {if (__DEV__) {  const OuterV1 = render(() => {function Hello() {  const [val, setVal] = React.useState(0);  return (  {val}</p>  );}$RefreshReg$(Hello, 'Hello');const Outer = React.forwardRef(() => <Hello />);$RefreshReg$(Outer, 'Outer');return Outer;  });  // Bump the state before patching.  const el = container.firstChild;  expect(el.style.color).toBe('blue');  act(() => {el.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(el.textContent).toBe('1');  // Perform a hot update.  const OuterV2 = patch(() => {function Hello() {  return (<p style={{color: 'red'}} onClick={() => setVal(val + 1)}>  {val}</p>  );}$RefreshReg$(Hello, 'Hello');const Outer = React.forwardRef(() => <Hello />);$RefreshReg$(Outer, 'Outer');return Outer;  });  // Assert the state was preserved but color changed.  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe('1');  expect(el.style.color).toBe('red');  // Bump the state again.  act(() => {el.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe('2');  expect(el.style.color).toBe('red');  // Perform top-down renders with both fresh and stale types.  //der(() => OuterV1);  render(() => OuterV2);  render(() => OuterV1);  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe('2');  expect(el.style.color).toBe('red');  // Finally, a render with incompatible type should reset it.  render(() => {function Hello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'blue'}} onClick={() => setVal(val + 1)}>  {val}  );}$RefreshReg$(Hello, 'Hello');// Note: no forwardRef wrapper this time.retur  const newEl = container.firstChild;  expect(newEl.textContent).toBe('0');  expect(newEl.style.color).toBe('blue');}  });  it('should not consider two forwardRefs around the same type to be equivalent', () => {if (__DEV__) {  const ParentV1 = render(() => {const [val, setVal] = React.useState(0);return (  <p style={{color: 'blue'}} onClick={() => setVal(val + 1)}>{val}  </p>);  }  $RefreshReg$(Hello, 'Hello');  function renderInner() {return <Hello />;  }  // Both of these are wrappe  const ForwardRefA = React.forwardRef(renderInner);  $RefreshReg$(ForwardRefA, 'ForwardRefA');  const ForwardRefB = React.forwardRef(renderInner);  $Re  }  $RefreshReg$(Parent, 'Parent');  return Parent;},{cond: true},  let el = container.firstChild;  expect(el.textContent).toBe('0');  expect(el.style.color).toBe('blue');  act(() => {el.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(el.textContent).toBe('1');expect(el).not.toBe(container.firstChild);  el = container.firstChild;  expect(el.textContent).toBe('0');  expect(el.style.color).toBe('blue');  act(() => {el.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(el.textContent).toBe('1');  // Switch them up back again.  render(() => ParentV1, {cond: true});  expect(el).not.toBe(container.first  expect(el.textContent).toBe('0');  expect(el.style.color).toBe('blue');  // Now bump up the state to prepare for patching.  act(() => {el.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(el.textContent).toBe('1');  // Patch to change the color.  const ParentV2 = patch(() => {function Hello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'red'}} onC</p>  );}  return <Hello />;}// Both of these are wrappers around the same inner function.// They should be treated as distinct types across reloads.const ForwardRefA = React.forwardRef(renderInner);$Refr$RefreshReg$(ForwardRefB, 'ForwardRefB');function Parent({cond}) {  return cond ? <ForwardRefA /> : <ForwardRefB />;}$RefreshReg$(Parent, 'Parent');return Parent;  });  // The state should be intact; the color should change.  expect(el).toBe(container.firstChild);  expect(el.textContent).toBe('1');  expect(el.style.color).toBe('red');  // Switching up the condition should still reset the state.  render(() => ParentV2, {cond: false});  expect(el).not.toBe(container.firstChild);  el = container.firstChild;  expect(el.textContent).toBe('0');  expect(el.style.color).toBe('el.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(el).toBe(container.firstChild);  expect(el.textContent).toBe('1');  expect(el.style.color).toBe('red');  // Finally, verify using top-level render with stale type keeps state.  render(() => ParentV1);  render(() => ParentV2);  render(() => ParentV1);  expect(container.firstChild).toBe(el);  expect(el.style.color).toBe('red');}  });  it('can update forwardRef render function with its wrapper', () => {if (__DEV__) {function Hello({color}) {  const [val, setVal] = React.useState(0);  return (<p s</p>  );}$RefreshReg$(Hello, 'Hello');const Outer = React.forwardRef(() => <Hello color="blue" />);$RefreshReg$(Outer, 'Outer');return Outer;  });  // Bump the state before patching.  const el = container.firstChild;  expect(el.style.color).toBe('blue');  act(() => {el.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(el.textContent).toBe('1');  // Perform a hot update.  patch(() => {  const [val, setVal] = React.useState(0);  return (<p style={{color}} onClick={() => setVal(val + 1)}>  {val}  );}$RefreshReg$(Hello, 'Hello');const Outer = React.forwardRef(() => <Hello color="red" />);$RefreshReg$(Outer, 'Outer');return Outer;  });  // Assert the state was preserv  expect(el.textContent).toBe('1');  expect(el.style.color).toBe('red');}  });  it('can update forwardRef render function in isolation', () => {if (__DEV__) {function Hello({color}) {  const [val, setVal] = React.useState(0);  return (<p style={{color}} onClick={() => setVal(val + 1)}>  {val}</p>  );}$RefreshReg$(Hello, 'Hello');function renderHello() {  return <Hello color="blue" />;}  });  // Bump the state before patching.  const el = container.firstChild;  expect(el.textContent).toBe('0');  expect(el.style.color).toBe('blue');  act(() => {el.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(el.textContent).toBe('1');  // Perform a hot update of just the rendering function.  patch(() => {  const [val, setVal] = React.useState(0);  return (<p style={{color}} onClick={() => setVal(val + 1)}>  {val}  );}  return <Hello color="red" />;}$RefreshReg$(renderHello, 'renderHello');// Not updating the wrapper.  });  // Assert the state was preser  expect(el.textContent).toBe('1');  expect(el.style.color).toBe('red');}  });  it('can preserve state for simple memo', () => {if (__DEV__) {  const OuterV1 = render(() => {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'blue'}} onClick={() => setVal(val + 1)}>  {val}</p>  );}$RefreshReg$(Outer, 'Outer');return Outer;  });  // Bump the state before patching.  const el = container.firstChild;  expect(el.textContent).toBe('0');  expect(el.style.color).toBe('blue');  act(() => {el.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  const OuterV2 = patch(() => {function Hello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'red'}} onClick={() => setVal(val + 1)}>  {val}</p>  );}$RefreshReg$(Hello, 'Hello');const Outer = React.memo(Hello);$RefreshReg$(Outer, 'Outer');return Outer;  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe('1');  expect(el.style.color).toBe('red');  // Bump the state again.  act  });  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe('2');  expect(el.style.color).toBe('red');  // Perform top-down renders with both fresh and stale types.  // Neither should change the state or color.  // They should always resolve to the latest version.  render(() => OuterV1);  render(() => OuterV2);  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe('2');  expect(el.style.color).toBe('red');  // Finally, a render with incompatible type should reset it.  render(() => {function Hello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'blue'}} onClick={() => setVal(val + 1)}>  {val}</p>  );$RefreshReg$(Hello, 'Hello');// Note: no wrapper this time.return Hello;  });  expect(container.firstChild).not.toBe(el);  con  expect(newEl.style.color).toBe('blue');}  });  it('can preserve state for memo with custom comparison', () => {if (__DEV__) {  const OuterV1 = render(() => {funct  return (<p style={{color: 'blue'}} onClick={() => setVal(val + 1)}>  {val}</p>  );}const Outer = React.memo(Hello, () => true);$RefreshReg$(Outer, 'Outer');return Outer;  });  // Bump the state before patching.  const el = container.firstChild;  expect(el.textContent).toBe('0');  expect(el.style.color).toBeel.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(el.textContent).toBe('1');  // Perform a hot update.  const OuterV2 = patch(() => {  const [val, setVal] = React.useState(0);  ret  {val}</p>  );}const Outer = React.memo(Hello, () => true);$RefreshReg$(Outer, 'Outer');return Outer;  });  // Assert the state was preserved but color changed.  expect(container.firstChild).toBe  expect(el.style.color).toBe('red');  // Bump the state again.  act(() => {el.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe('2');  expect(el.style.color).toBe('red');  // Perform top-down renders with both fresh and stale types.  // Neither should change the state or color.  // They should always resolve to the latest version.  render(() => OuterV1);  render(() => OuterV2);  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe('2');  expect(el.style.color).toBe('red');  // Finally, a render with incompatible type should reset it.  render(() => {  const [val, setVal] = React.useState(0);  ret  {val}</p>  );}$RefreshReg$(Hello, 'Hello');// Note: no wrapper this time.retur  const newEl = container.firstChild;  expect(newEl.textContent).toBe('0');  expect(newEl.style.color).toBe('blue');}  });  it('can update simple memo function in isolation', () => {if (__DEV__) {  render(() => {function Hello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'blue'}} onClick={() => setVal(val + 1)}>  {val}  );}$RefreshReg$(Hello, 'Hello');return React.memo(Hello);  });  expect(el.textContent).toBe('0');  expect(el.style.color).toBe('blue');  act(() => {el.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(el.textContent).toBe('1');  // Perform a hot update of just the rendering function.  patch(() => {function Hello() {  return (<p style={{color: 'red'}} onClick={() => setVal(val + 1)}>  {val}</p>  );}$RefreshReg$(Hello, 'Hello');// Not updating the wrapper.  });  // Assert the state was preserved but color changed.  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe('1');  expect(el.style.color).toBe  });  it('can preserve state for memo(forwardRef)', () => {if (__DEV__) {  const OuterV1 = render(() => {funct  return (<p style={{color: 'blue'}} onClick={() => setVal(val + 1)}>  {val}</p>}$RefreshReg$(Hello, 'Hello');const Outer = React.memo(React.forwardRef(() => <Hello />));$RefreshReg$(Outer, 'Outer');return Outer;  });  // Bump the state before patching.  const el = container.firstChild;  expect(el.textContent).toBe('0');  act(() => {el.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(el.textContent).toBe('1');  // Perform a hot update.  const OuterV2 = patch(() => {function Hello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'red'}} onClick={()</p>  );}$RefreshReg$(Hello, 'Hello');const Outer = React.memo(React.forwardRef(() => <Hello />));$RefreshReg$(Outer, 'Outer');return Outer;  });  // Assert the state was preserved but color changed.  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe('1');  expect(el.style.color).toBe('red');  // Bump the state again.  act(() => {  });  expect(container.firstChild).toBe(el);  exp  // Neither should change the state or color.  // They should always resolve to the latest version.  render(() => OuterV1);  render(() => OuterV2);  render(() => OuterV1);  exp  expect(el.style.color).toBe('red');  // Finally, a render with incompatible type should reset it.  render(() => {function Hello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'blue'}} onClick={() => setVal(val + 1)}>  {val}</p>  );}$  });  expect(container.firstChild).not.toBe(el);  const newEl = container.firstChild;  expect(newEl.textContent).toBe('0');  exp  });  it('can preserve state for lazy after resolution', async () => {if (__DEV__) {  const AppV1 = render(() => {function Hello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'blue'}} onClick={() => setVal(val + 1)}>  {val}  );}$RefreshReg$(Hello, 'Hello');const Outer = React.lazy(  () =>new Promise(resolve => {  setTimeout(() => resolve({default: Hello}), 100);}),);$RefreshReg$(Outer, 'Outer');function App() {ter /></React.Suspense>  );}  });  expect(container.textContent).toBe('Loading');  await act(() => {jest.runAllTimers();  });  const el = container.firstChild;  expect(el.textContent).toBe('0');  expect(el.style.color).toBe('blue');  act(() => {el.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(el.textContent).toBe('1');  function Hello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'red'}} onClick={() => setVal(val + 1)}>  {val}</p>  );}$RefreshReg$(Hello, 'Hello');const Ounew Promise(resolve => {  setTimeout(() => resolve({default: Hello}), 100);}),);$RefreshReg$(Outer, 'Outer');function App() {  return (<React.Suspense fallback={<p>Loading</p>}>  <Outer /></React.Suspense>  );}  });  // Assert the state was preserved but color changed.  expect(container.firstChild).toBe(el);  exp  act(() => {el.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe('2');  exp  // They should always resolve to the latest version.  render(() => AppV1);  render(() => AppV2);  render(() => AppV1);  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe('2');  expect(el.style.color).toBe('red');  // Finally, a render with incompatible type should reset it.  render(() => {function Hello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'blue'}} on</p>  );$RefreshReg$(Hello, 'Hello');// Note: no lazy wrapper this time.function App() {  return (<React.Suspense fallback={<p>Loading</p>}>  <Hello /></React.Suspense>  );}$RefreshReg$(App, 'App');return App  const newEl = container.firstChild;  expect(newEl.textContent).toBe('0');  expect(newEl.style.color).toBe('blue');}  });  it('can patch lazy before resolution', async () => {if (__DEV__) {  render(() => {function Hello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'blue'}} on</p>  );$RefreshReg$(Hello, 'Hello');const Outer = React.lazy(  () =>new Promise(resolve => {  setTimeout(() => resolve({default: Hello}), 100);}),);  return (<React.Suspense fallback={<p>Loading</p>}>  <Outer /></React.Suspense>  );}return App;  });  expect(container.textContent).toBe('Loading');  // Perform a hot update.  patch(() => {function Hello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'red'}} onC</p>  );}$Refrjest.runAllTimers();  });  // Expect different color on initial mount.  const el = container.firstChild;  expect(el.textContent).toBe('0');  expect(el.style.color).toBe('red');  // Bump state.  act(() => {el.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(el.textContent).toBe('1');  expect(el.style.color).toBe('red');  // Test another reload.  patch(() => {function Hello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'orange'}} onClick={() => setVal(val + 1)}>  {val}</p>  );}  });  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe('1');  exp  });  it('can patch lazy(forwardRef) before resolution', async () => {if (__DEV__) {  render(() => {function renderHello() {  return (<p style={{color: 'blue'}} onClick={() => setVal(val + 1)}>  {val}</p>  );}const Hello = React.forwardRef(render  () =>new Promise(resolve => {  setTimeout(() => resolve({default: Hello}), 100);}),);$RefreshReg$(Outer, 'Outer');function App() {  return (<React.Suspense fallback={<p>Loading</p>}>  <Outer />  );}return App;  });  expect(container.textContent).toBe('Loading');  // Perform a hot update.  patch(() => {function renderHello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'red'}} onClick={() => setVal(val + 1)}>  {val}</p>  );const Hello = React.forwardRef(renderHello);$RefreshReg$(Hello, 'Hello');  });  });  // Expect different color on initial mount.  const el = container.firstChild;  expect(el.textContent).toBe('0');  expect(el.style.color).toBe('red');  // Bump state.  act(() => {el.di  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe('1');  expect(el.style.color).toBe('red');  // Test another reload.  patch(() => {function renderHello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'orange'}} onClick={() => setVal(val + 1)}>  {val}</p>  );}$RefreshReg$(Hello, 'Hello');  });  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe('1');  expect(el.style.color).toBe('orange');}  });  it('can patch lazy(mem  render(() => {function renderHello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'blue'}} onClick={() => setVal(val + 1)}>  {val}</p>  );const Hello = React.memo(renderHello);$Refrnew Promise(resolve => {  setTimeout(() => resolve({default: Hello}), 100);}),);$RefreshReg$(Outer, 'Outer');function App(<React.Suspense fallback={<p>Loading</p>}>  <Outer /></React.Suspense>  );}return App;  });  expect(container.textContent).toBe('Loading');  // Perform a hot update.  patch(() => {function renderHello() {  return (<p style={{color: 'red'}} onClick={() => setVal(val + 1)}>  {val}</p>  );}const Hello = React.memo(renderHello);$RefreshReg$(Hello, 'Hello');  });  await act(() => {jest.runAllTimers();  });  // Expect different co  expect(el.textContent).toBe('0');  expect(el.style.color).toBe('red');  // Bump state.  act(() => {el.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe  patch(() => {function renderHello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'orange'}} onClick={() => setVal(val + 1)}>  {val}</p>  );const Hello = React.memo(renderHello);$Refr  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe('1');  expect(el.style.color).toBe('orange');}if (__DEV__) {  render(() => {function renderHello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'blue'}} onClick={() => setVal(val + 1)}>  {val}  );}const Hello = React.memo(React.forwardRef(renderHello));$RefreshReg$(Hello, 'Hello');const Outer = React.lazy(  () =>new Promise(resolve => {  setTimeout(() => resolve({default: Hello}), 100);}),);  return (<React.Suspense fallback={<p>Loading</p>}>  <Outer /></React.Suspense>  );}return App;  });  expect(container.textContent).toBe('Loading');  // Perform a hot update.  patch(() => {function renderHello() {  const [val, setVal] = React.useState(0);  return (  {val}  );}const Hello = React.memo(React.forwardRef(renderHello));$RefreshReg$(Hello, 'Hello');  });  await act(() => {jest.runAllTimers();  });  // Expect different color on initial mount.  const el = container.fi  expect(el.style.color).toBe('red');  // Bump state.  act  });  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe('1');  expect(el.style.color).toBe('red');  // Test another reload.  patch(() => {funct  return (<p style={{color: 'orange'}} onClick={() => setVal(val + 1)}>  {val}</p>  );}const Hello = React.memo(React.forwardRef(renderHello));$RefreshReg$(Hello, 'Hello');  });  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe('1');  expect(el.style.color).toBe  });  it('can patch both trees while suspense is displaying the fallback', async () => {if (__DEV__) {  const AppV1 = render(() => {  function Hello({children}) {const [val, setVal] = React.useState(0);return ({children} {val}  </p>);  }  $RefreshReg$(Hello, 'Hello');  function Never() {throw new Promise(resolve => {});act.Suspense fallback={<Hello>Fallback</Hello>}><Hell  </React.Suspense>  }  return App;},{shouldSuspend: false},  );  // We start with just the primary tree.  expect(container.childNodes.length).toBe(1);  const primaryChild = container.firstChild;  expect(primaryChild.textContent).toBe('Content 0');  expect(primaryChild.style.color).toBe('blue');  expect(primaryChild.style.display).toBe('');  // Bump primary content state.  act(() => {primaryChild.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(container.childNodes[0]).toBe(primaryChild);  expect(primaryChild.textContent).toBe('Content 1');  exp  patch(() => {function Hello({children}) {  const [val, setVal] = React.useState(0);  return (  {children} {val}</p>  );}$RefreshReg$(Hello, 'Hello');  });  expect(container.childNodes.length)  expect(primaryChild.textContent).toBe('Content 1');  expect(primaryChild.style.color).toBe('green');  expect(primaryChild.style.display).toBe('');  // Now force the tree to suspend.  render(() => AppV1, {shouldSuspend: true});  // Expect to see two trees, one of them is hidden.  expect(container.childNodes.length).toBe(2);  expect(container.childNodes[0]).toBe(primaryChild);  const fallbackChild = container.childNodes[1];  expect(primaryChild.textContent).toBe('Content 1');  expect(primaryChild.style.color).toBe('green');  expect(primaryChild.style.display).toBe('none');  expect(fallbackChild.textContent).toBe('Fallback 0');  expect(fallbackChild.style.color).toBe('green');  expect(fallbackChild.style.display).toBe('');  // Bump fallback state.  act(() => {fallbackChild.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  exp  expect(container.childNodes[1]).toBe(fallbackChild);  expect(primaryChild.textContent).toBe('Content 1');  expect(primaryChild.style.color).toBe('green');  expect(primaryChild.style.display).toBe('none');  expect(fallbackChild.textContent).toBe('Fallback 1');  expect(fallbackChild.style.color).toBe('green');  expect(fallbackChild.style.display).toBe('');  // Perform a hot update.  patch(() => {function Hello({children}) {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'red'}} onClick={() => setVal(val + 1)}>  {children} {val}  );}$RefreshReg$(Hello, 'Hello');  });  // Colors inside both trees should change:  expect(container.childNodes.length).toBe(2);  expect(container.childNodes[0]).toBe(primaryChild);  expect(container.childNodes  expect(primaryChild.style.color).toBe('red');  expect(primaryChild.style.display).toBe('none');  expect(fallbackChild.textContent).toBe('Fallback 1');  expect(fallbackChild.style.color).toBe('red');  expect(fallbackChild.style.display).toBe('');  // Only primary tree should exist now:  render(() => AppV1, {shouldSuspend: false});ect(primaryChild.textContent).toBe('Content 1');  exp  patch(() => {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'orange'}} onClick={() => setVal(val + 1)}>  {children} {val}</p>  );}$RefreshReg$(Hello, 'Hello');  });  expect(container.childNodes.length).toBe(1);  expect(container.childNodes[0]).toBe(primaryChild);  expect(primaryChild.textContent).toBe('Content 1');  exp}  });  it('does not re-render ancestor components unnecessarily during a hot update', () => {if (_function Hello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'blue'}} onClick={(</p>  );}$RefreshReg$(Hello, 'Hello');function App() {  appRenders++;  return <Hello />;$RefreshReg$(App, 'App');return App;  });  expect(appRenders).toBe(1);  // Bump the state before patching.  const el = container.firstChild;  expect(el.textContent).toBe('0');  expect(el.style.color).toBe('blue');  act(() => {el.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(el.textContent).toBe('1');  // No re-renders from the top.  expect(appRenders).toBe(1);  // Perform a hot update for Hello only.  patch(() => {function Hello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'red'}} onClick={() => setVal(val + 1)}>  {val}</p>}$RefreshReg$(Hello, 'Hello');  });  // Assert the state was preserved but color changed.  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe('1');  expect(el.style.color).toBe('red');  // Still no re-renders from the top.  expect(appRenders).toBe(1);  // Bump the state.  act(() => {el.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(el.textContent).toBe('2');  // Still no re-renders from the top.  expect(appRenders).toBe(1);}if (__DEV__) {  let helloRenders = 0;  render(() => {function Hello({children}) {  helloRenders++;  return <div>X{children}X</div>;}$RefreshReg$(Hello, 'Hello');<Hello>  <Hello><Hello />  </Hello>  <Hello><Hello />}  });  expect(container.textContent).toBe('XXXXXXXXXX');  helloRenders = 0;  patch(() => {function Hello({children}) {  helloRenders++;  return <div>O{children}O</div>;}$RefreshReg$(Hello, 'Hello');  });  expect(helloRenders).toBe(5);  expect(container.textContent).toBe('OOOOOOOOOO');}  });  it('does not leak state between components', () => {if (_() => {  function Hello1() {const  <p style={{color: 'blue'}} onClick={() => setVal(val + 1)}>{val}  </p>);  $RefreshReg$(Hello1, 'Hello1');  function Hello2() {const [val, setVal] = React.useState(0);return (  <p style={{color: 'blue'}} onClick={() => setVal(val + 1)}>{val}  </p>  }  $RefreshReg$(Hello2, 'Hello2');  function App({cond}) {return cond ? <Hello1 /> : <Hello2 />;  }  $RefreshReg$(App, 'App');  return App;},{cond: false},  );  // Bump the state before patching.  const el = container.firstChild;  expect(el.textContent).toBe('0');  expect(el.style.color).toBe('blue');  act(() => {el.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(el.textContent).toBe('1');  // Switch the condition, flipping inner content.  //st el2 = container.firstChild;  expect(el2).not.toBe(el);  expect(el2.textContent).toBe('0');  expect(el2.style.color).toBe('blue');  // Bump it again.  act(() => {el2.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(el2.textContent).toBe('1');  // Perform a hot update for both inner components.  patch(() => {function Hello1() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'red'}} onC</p>  );}$RefreshReg$(Hello1, 'Hello1');function Hello2() {  const [val, setVal] = React.useState(0);  return (  {val}</p>  );}$RefreshReg$(Hello2, 'Hello2');  });  // Assert the state was preserved but color changed.ect(el2.style.color).toBe('red');  // Flip the condition again.  ren  expect(el3).not.toBe(el2);  expect(el3.style.color).toBe('red');}  });  it('can force remount by changing signature', () => {if (__DEV__) {  const HelloV1 = render(() => {function Hello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'blue'}} onClick={() => setVal(val + 1)}>  {val}</p>  );}// When this changes, we'll expect a remount:$RefreshSig$(Hello, '1');retur  const el = container.firstChild;  expect(el.textContent).toBe('0');  expect(el.style.color).toBe('blue');  act(() => {  });  expect(el.textContent).toBe('1');  // Perform a hot update.  const HelloV2 = patch(() => {function Hello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'red'}} onClick={()</p>  );}$RefreshReg$(Hello, 'Hello');// The signature hasn't changed since the last time:$RefreshSig$(Hello, '1');return Hello;  });  // Assert the state was preserved but color changed.  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe('1');  expect(el.style.color).toBe('red');  // Perform a hot update.  const HelloV3 = patch(() => {function Hello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'yellow'}} onClick={() => setVal(val + 1)}>  {val}</p>}// We're changing the signature now so it will remount:$RefreshReg$(Hello, 'Hello');$RefreshSig$(Hello, '2');return Hello;  });  // Expect a remount.  expect(container.firstChild).not.toBe(el);  const newEl = container.firstChild;  expect(newEl.textContent).toBe('0');  expect(newEl.style.color).toBe('yellow');  // Bump state again.  act(() => {newEl.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(newEl.style.color).toBe('yellow');  // Perform top-down renders with both fresh and stale types.  // Neither should change the state or color.  /  render(() => HelloV2);  render(() => HelloV3);  render(() => HelloV2);  render(() => HelloV1);  expect(container.firstChild).toBe(newEl);  expect(newEl.textContent).toBe('1');  expect(newEl.style.color).toBe('yellow');  // Verify we can patch again while preserving the signature.  p  const [val, setVal] = React.useState(0);  return (<p style={{color: 'purple'}} onClick={() => setVal(val + 1)}>  {v  );}// Same signature as last time.$RefreshReg$(Hello, 'Hello');$RefreshSig$(Hello, '2');return Hello;  expect(newEl.textContent).toBe('1');  expect(newEl.style.color).toBe('purple');  // Check removing the signature also causes a remount.  patch(() => {function Hello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'orange'}} onClick={() => setVal(val + 1)}>  {val}</p>}// No signature this time.$RefreshReg$(Hello, 'Hello');return Hello;  });  // Expect a remount.  expect(container.firstChild).not.toBe(newEl);  const finalEl = container.firstChild;  expect(finalEl.textContent).toBe('0');  expect(finalEl.style.color).toBe('orange');}  });  it('keeps a valid tree when forcing remount', () => {if (__DEV__) {  const HelloV1 = prepare(() => {function Hello() {  return null;}$RefreshReg$(Hello, 'Hello');return Hello;  });  const Bailout = React.memo(({children}  });  // Each of those renders three instances of HelloV1,  // but in different ways.  const trees = [<div>  <HelloV1 />  <div><HelloV1 /><Bailout>  <HelloV1 /></Bailout></div>,<div>  <div><HelloV1>  <HelloV1 /></HelloV1><HelloV1 />  </div></div>,<div>  <span />  <HelloV1 />  <HelloV1 /></div>,<div>  <HelloV1 />  <span />  <HelloV1 />  <HelloV1 /></div>,<div>  <div>foo</div>  <HelloV1 />  <div><Hell  <HelloV1 />  <span /></div>,<div>  <HelloV1><span />Hello<span />  </HelloV1>  ,<>  <HelloV1 /></>  </HelloV1>  ,</div>,<HelloV1><Bailout>  <span />  <HelloV1><span />  </HelloV1>  <span /></Bailout>  </HelloV1></HelloV1>,<div>  <span />  <HelloV1 key="0" />  <HelloV1 key="1" />  <HelloV1 key="2" />  <span /></div>,<div>  <span />  {nu  {null}  <HelloV1 />  <HelloV1 /></div>,<div>  <HelloV1 key="2" />  <span />  <HelloV1 key="0" />  <span />  <HelloV1 key="1" /></div>,<div>  {[[<HelloV1 key="2" />]]}  <span><HelloV1 key="0" />{[null]}<HelloV1 key="1" />  </span></div>,<div>  <span><HelloV1 key="x" />  </span></div>,<HelloV1>  <HelloV1><span /><Bailout>  <HelloV1>hi</HelloV1></Bailout>  </HelloV1>  ];  // First, check that each tree handles remounts in isolation.  ReactDOM.render(null, container);  for (let i = 0; i < trees.length; i++) {runRemountingStressTest(trees[i]);  }  // Then check that each tree is resilient to updates from another tree.  for (let i = 0; i < trees.length; i++) {for (let j = 0; j < trees.length; j++) {  ReactDOM.render(null, container);  // Intentionally don't clean up between the tests:  runRemountingStressTest(trees[i]);  runRemountingStressTest(trees[j]);  run  }}  });  function runRemountingStressTest(tree) {patch(() => {return <section data-color="blue">{children}</section>;  }  $RefreshSig$(Hello, '1');  return Hello;});ReactDOM.render(tree, container);const elements = container.querySelectorAll('section');// Each tree above produces exactlyelements.forEach(el => {  expect(el.dataset.color).toBe('blue');});// Patch color without changing the signature.patchreturn <section data-color="red">{children}</section>;  }  $RefreshReg$(Hello, '  return Hello;});const elementsAfterPatch = container.querySelectorAll('section');expect(elementsAfterPatch.length).toBe(3);elementsAfterPatch.forEach((el, index) => {  // The signature hasn't changed so we expect DOM nodes to stay the same.  expect(el).toBe(elements[in  expect(el.dataset.color).toBe('red');});// Patch color *and* change the signature.patch(() => {  function Hello({children}) {return <section data-color="orange">{children}</section>;  }  $RefreshReg$(Hello, 'Hello');  $RefreshSig$(Hello, '2'); // Remount  return Hello;});const elementsAfterRemount = container.querySelectorAll('section');expect(elementsAfterRemount.length).toBe(3);elementsAfterRemount.forEach((el, index) => {  // The signature changed so we expect DOM nodes to be different.  expect(el).not.toBe(elements[index]);  // They should all be using the new color:  expect(el.dataset.color).toBe('orange');});// Now patch col  function Hello({children}) {return <section data-color="black">{children}</section>;  }  $RefreshReg$(Hello, 'Hello');  $RefreshSig$(Hello, '2'); // Same signature as before  return Hello;});expect(container.querySelectorAll('section').length).toBe(3);container.querySelectorAll('section').forEach((el, index) => {  // The signature didn't change so DOM nodes should stay the same.  expect(el).toBe(elementsAfterRemount[index]);  // });// Do another render just in case.ReactDOM.render(tree, container);expect(container.querySelectorAll('section').length).toBe(3);container.querySelectorAll('section').forEach((el, index) => {  expect(el).toBe(elementsAfterRemount[index]);  expect(el.dataset.color).toBe('black');});  }  it('can remount on signature change within a <root> wrapper', () => {if (__DEV__) {  testRemountingWithWrapper(Hello => Hello);}  });  it('can remount on signature change within a simple memo wrapper', () => {if (__DEV__) {  testRemountingWithWrapper(Hello => React.memo(Hello));}  });  it('can remount on signature change within a lazy simple memo wrapper', () => {if (__DEV__) {  testRemountingWithWrapper(Hello =>React.lazy(() => ({  then(cb) {cb({default: React.memo(Hello)});  },})),  );}  });  it('can remount on signature change within forwardRef', () => {if (__DEV__) {  testRemountingWithWrapper(Hello => React.forwardRef(Hello));}  })  testRemountingWithWrapper(Hello => React.forwardRef(() => <Hello />));}  });  it('can remount on signature change within nested memo', () => {if (__DEV__) {  testRemountingWithWrapper(Hello =>React.memo(React.memo(React.memo(Hello))),  );}if (__DEV__) {  testRemountingWithWrapper(Hello => React.memo(Hello, () => true));}  });  it('can remount on signature change within a class', () => {if (__DEV__) {  testRemountingWithWrapper(Hello => {const child = <Hello />;  render() {return child;  }};  });  });  it('can remount on signature change within a context provider', () => {if (__DEV__) {  testRemountingWithWrapper(Hello => {const Context = React.createContext();const child = (  <Context.Provider value="constant"><Hello />  </Context.Provider>);return function Wrapper() {  return child;};  });}  });  it('can remount on signature change within a context consumer', () => {if (__DEV__) {  testRemountingWithWrapper(Hello => {const Context = React.createContext();const child = <Context.Consumer>{() => <Hello />}</Context.Consumer>;return function Wrapper() {  ret  });}  });  it('can remount on signature change within a suspense node', () => {if (__DEV__) {// TODO: we'll probably want to test fallback trees too.const child = (  <React.Suspense><Hello />  </React.Suspense>);return function Wrapper() {  ret  });}  });  it('can remount on signature change within a mode node', () => {if (__DEV__) {  testRemountingWithWrapper(Hello => {const child = (  <React.StrictMode><Hello />  </React.StrictMode>);return function Wrapper() {  return child;};  });}  });  testRemountingWithWrapper(Hello => {const child = (  <><Hello />  </>);return function Wrapper() {  return child;  });}  });  it('can remount on signature change within multiple siblings', () => {if (__DEV__) {  testRemountingWithWrapper(Hello => {const child = (  <><>  <React.Fragment /></><Hello /><React.Fragment />  </>);retur};  });}  });  it('can remount on signature c  testRemountingWithWrapper(Hello => {const child = <Hello />;return function Wrapper() {  return (<React.Profiler onRender={() => {}} id="foo">  {child}</React.Profiler>  );};  });}  });  function testRemountingWithWrapper(wrap) {render(() => {  function Hello() {const  <p style={{color: 'blue'}} onClick={() => setVal(val + 1)}>{val}  </p>);  }  // When this changes, we'll expect a remount:  $RefreshSig$(Hello, '1');  // Use the passed wrapper.  // This will be different in every test.  return wrap(Hello);});// Bump the state before patching.const el = container.firstChild;expect(el.style.color).toBe('blue');act(() => {  el.dispatchEvent(new MouseEvent('click', {bubbles: true}));});expect(el.textContent).toBe('1');// Perform a hot update that doesn't remount.patch(() => {  function Hello() {const [val, setVal] = React.useState(0);return (  <p style={{color: 'red'}} onClick={() => setVal(val + 1)}>{val});  }  $RefreshReg$(Hello, 'Hello');  // The signature hasn't changed since the last time:  $RefreshSig$(Hello, '1');  return Hello;});// Assert the state was preserved but color changed.expect(container.firstChild).toBe(el);expect(el.textContent).toBe('1');expect(el.style.color).toBe('red');// Perform a hot update that remounts.patch(() => {  function Hello() {const [val, setVal] = React.useState(0);return (  <p>);  }  $RefreshReg$(Hello, 'Hello');  $RefreshSig$(Hello, '2');  return Hello;});// Expect a remount.expect(container.firstChild).not.toBe(el);const newEl = container.firstChild;expect(newEl.textContent).toBe('0');expect(newEl.style.color).toBe('yellow');// Bump state again.act(() => {  newEl.dispatchEvent(new MouseEvent('click', {bubbles: true}));});expect(newEl.textContent).toBe('1');expect(newEl.style.color).toBe('yellow');// Verify we can patch again while preserving the signature.patchconst [val, setVal] = React.useState(0);return (  <p style={{color: 'purple'}} onClick={() => setVal(val + 1)}>{val}  </p>);  }  $RefreshReg$(Hello, 'Hello');  $RefreshSig$(Hello, '2');  return Hello;});expect(container.firstChild).toBe(newEl);expect(newEl.textContent).toBe('1');expect(newEl.style.color).toBe('purple');// Check removing the signature also causes a remount.patch(() => {  function Hello() {const [val, setVal] = React.useState(0);retur{val}  </p>);  // No signature this time.  $RefreshReg$(Hello, 'Hello');  return Hello;});// Expect a remount.expect(container.firstChild).not.toBe(newEl);const finalEl = container.firstChild;expect(finalEl.textContent).toBe('0');expect(finalEl.style.color).toBe('orange');  }  it('resets hooks with dependencies on hot reload', () => {if (__DEV__) {  let useEffectWithEmptyArrayCalls = 0;  render(() => {function Hello() {  const [val, setVal] = React.useState(0);  const tranformed = React.useMemo(() => val * 2, [val]);  const handleClick = React.useCallback(() => setVal(v => v + 1), []);  React.useEffect(() => {useEffectWithEmptyArrayCalls++;  }, []);  return (<p style={{color: 'blue'}} onClick={handleClick}>  {tranformed}</p>  );}$RefreshReg$(Hello, 'Hello');return Hello;  });  // Bump the state before patching.  const el = container.firstChild;  expect(el.textContent).toBe('0');  expect(el.style.color).toBe('blue');  expect(useEffectWithEmptyArrayCalls).toBe(1); // useEffect ran  act(() => {el.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(el.textContent).toBe('2'); // val * 2  expect(useEffectWithEmptyArrayCalls).toBe(1); // useEffect didn't re-run  // Perform a hot update.  act(() => {patch(() => {  function Hello() {const [val, setVal] = React.useState(0);const tranformed = React.useMemo(() => val * 10, [val]);const handleClick = React.useCallback(() => setVal(v => v - 1), []);React.useEffect(() => {  useEffectWithEmptyArrayCalls++;}, []);return (  <p style={{color: 'red'}} onClick={handleClick}>{tranformed}  </p>);  }  $RefreshReg$(Hello, 'Hello');  return Hello;});  });  // Assert the state was preserved but memo was evicted.  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe('10'); // val * 10  expect(el.style.color).toBe('red');  expect(useEffectWithEmptyArrayCalls).toBe(2); // useEffect re-ran  // This should fire the new callback which decreases the counter.  act(() => {el.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(el.textContent).toBe('0');  expect(el.style.color).toBe('red');  expect(useEffectWithEmptyArrayCalls).toBe(2); // useEffect didn't re-run}  });  // This pattern is inspired by useSubscription and similar mechanisms.  it('does not get into infinite loops during render phase updates', () => {if (__DEV__) {  render(() => {function Hello() {  const source = React.useMemo(() => ({value: 10}), []);  const [state, setState] = React.useState({value: null});  if (state !== source) {setState(source);  }  return <p style={{color: 'blue'}}>{state.value}</p>;}$RefreshReg$(Hello, 'Hello');return Hello;  });  const el = container.firstChild;  expect(el.textContent).toBe('10');  expect(el.style.color).toBe('blue');  // Perform a hot update.  act(() => {patch(() => {  function Hello() {const source = React.useMemo(() => ({value: 20}), []);const [state, setState] = React.useState({value: null});if (state !== source) {  // This should perform a single render-phase update.  setState(source);}return <p style={{color: 'red'}}>{state.value}</p>;  }  $RefreshReg$(Hello, 'Hello');  return Hello;});  });  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe('20');  expect(el.style.color).toBe('red');}  });  // @gate www && __DEV__  it('can hot reload offscreen components', async () => {const AppV1 = prepare(() => {  function Hello() {React.useLayoutEffect(() => {  Scheduler.log('Hello#layout');});const [val, setVal] = React.useState(0);return (  <p style={{color: 'blue'}} onClick={() => setVal(val + 1)}>{val}  </p>);  }  $RefreshReg$(Hello, 'Hello');  return function App({offscreen}) {React.useLayoutEffect(() => {  Screturn (  <LegacyHiddenDiv mode={offscreen ? 'hidden' : 'visible'}><Hello />  </LegacyHiddenDiv>);});const root = ReactDOMClient.createRoot(container);root.render(<AppV1 offscreen={true} />);await waitFor(['App#layout']);const el = container.firstChild;expect(el.hidden).toBe(true);expect(el.firstChild).toBe(null); // Offscreen content not flushed yet.// Perform a hot update.patch(() => {  function Hello() {React.useLayoutEffect(() => {  Scheduler.log('Hello#layout');});const  <p style={{color: 'red'}} onClick={() => setVal(val + 1)}>{val}  </p>);  }  $RefreshReg$(Hello, 'Hello');});// It's still offscreen so we don't see anything.expect(container.firstChild).toBe(el);expawait waitFor(['Hello#layout']);expect(container.firstChild).toBe(el);expect(el.firstChild.textContent).toBe('0');expect(el.firstChild.style.color).toBe('red');await internalAct(() => {  el.firstChild.dispatchEvent(new MouseEvent('click', {  b  );});assertLog(['Hello#layout']);expect(el.firstChild.textContent).toBe('1');expect(el.firstChild.style.color).toBe('red');// Hot reload while we're offscreen.patch(() => {  function Hello() {React.useLayoutEffect(() => {  Scheduler.log('Hello#layout');});return (  <p style={{color: 'orange'}} onClick={() => setVal(val + 1)}>{val}  </p>);  }  $RefreshReg$(Hello, 'Hello');});expect(el.firstChild.textContent).toBe('1');expect(el.firstChild.style.color).toBe('red');// Process the offscreen updates.await waitFor(['Hello#layout']);expect(container.firstChild).toBe(el);expect(el.firstChild.textContent).toBe('1');expect(el.firstChild.style.color).toBe('orange');  });  it('remounts failed error boundaries (componentDidCatch)', () => {if (__DEV__) {  r  return <h1>Hi</h1>;}$RefreshReg$(Hello, 'Hello');class Boundary extends React.Component {  state = {error: null};  componentDidCatch(error) {this.setState({error});  }  r  return <h1>Oops: {this.state.error.message}</h1>;}return this.props.children;  }}function App() {  return (<>  <p>A</p>  <  </Boundary>  <p>B</p></>  );}return App;  });  expect(container.innerHTML).toBe('<p>A</p><h1>Hi</h1><p>B</p>');  c  patch(() => {function Hello() {  throw new Error('No');}$RefreshReg$(Hello, 'Hello');  });  expect(container.innerHTML).toBe('<p>A</p><h1>Oops: No</h1><p>B</p>');  expect(container.firstChild).toBe(firstP);  efunction Hello() {  return <h1>Fixed!</h1>;}$RefreshReg$(Hello, 'Hello');  });  expect(container.firstChild).toBe(firstP);  expect(container.firstChild.nextSibling.nextSibling).toBe(secondP);  // Verify next hot reload doesn't remount anything.  const helloNode = container.firstChild.nextSibling;  patch(() => {funct}$RefreshReg$(Hello, 'Hello');  });  expect(container.firstChild.nextSibling).toBe(helloNode);  expect(helloNode.textContent).toBe('Nice.');}  });  it('remounts failed error boundaries (getDerivedStateFromError)', () => {if (__DEV__) {  render(() => {function Hello() {  ret$RefreshReg$(Hello, 'Hello');class Boundary extends React.Component {  state = {error: null};  static getDerivedStateFromError(error) {return {error};  }if (this.state.error) {  return <h1>Oops: {this.state.error.message}</h1>;}return this.props.children;  }  return (<>  <p>A</p>  <Boundary><Hello />  </Boundary>  <p>  );}return App;  });  expect(container.innerHTML).toBe('<p>A</p><h1>Hi</h1><p>B</p>');  const firstP = container.firstChild;  confunction Hello() {  throw new Error('No');}$RefreshReg$(Hello, 'Hello');  });  expect(container.innerHTML).toBe('<p>A</p><h1>Oops: No</h1><p>B</p>');  expect(container.firstChild).toBe(firstP);  expect(container.firstChild.nextSibling.nextSibling).toBe(secondP);  // Perform a hot update that fixes the error.  patch(() => {function Hello() {  return <h1>Fixed!</h1>;}$Refr  expect(container.innerHTML).toBe('<p>A</p><h1>Fixed!</h1><p>B</p>');  expect(container.firstChild).toBe(firstP);  expect(container.firstChild.nextSibling.nextSibling).toBe(secondP);  // Verify next hot reload doesn't remount anything.  const helloNode = container.firstChild.nextSibling;  patch(() => {function Hello() {  return <h1>Nice.</h1>;}$RefreshReg$(Hello, 'Hello');  });  expect(container.firstChild.nextSibling).toBe(helloNode);  expect(helloNode.textContent).toBe('Nice.');}  });  it('remounts error boundaries that failed asynchronously after hot update', () => {if (_function Hello() {  const [x] = React.useState('');  React.useEffect(() => {}, []);  x.slice(); // Doesn't throw initially.  return <h1>Hi</h1>;}$RefreshReg$(Hello, 'Hello');class Boundary extends React.Component {  state = {error: null};  static getDerivedStateFromError(error) {return {error};  }if (this.state.error) {  return <h1>Oops: {this.state.error.message}</h1>;}return this.props.children;  }}function App() {  return (<>  <p>A</p>  <Boundary><Hello />  </Boundary>  <p>B</p></>  );  });  expect(container.innerHTML).toBe('<p>A</p><h1>Hi</h1><p>B</p>');  const firstP = container.firstChild;  const secondP = firstP.nextSibling.nextSibling;  // Perform a hot update that fails.  act(() => {patch(() => {  function Hello() {const [x, setX] = React.useState('');React.useEffect(() => {  setTimeout(() => {setX(42); // This will crash next render.  }, 1);}, []);x.slice();retur  $RefreshReg$(Hello, 'Hello');});  });  expect(container.innerHTML).toBe('<p>A</p><h1>Hi</h1><p>B</p>');  // Run timeout inside effect:  act(() => {jest.runAllTimers();  });  expect(container.innerHTML).toBe('<p>A</p><h1>Oops: x.slice is not a function</h1><p>B</p>',  );  expect(container.firstChild).toBe(firstP);  expect(container.firstChild.nextSibling.nextSibling).toBe(secondP);  // Perform a hot update that fixes the error.  act(() => {patchconst [x] = React.useState('');React.useEffect(() => {}, []); // Removes the bad effect code.x.slice(); // Doesn't throw initially.return <h1>Fixed!</h1>;  }  $RefreshReg$(Hello, 'Hello');});  });  // This should remount the error boundary (but not anything above it).  expect(container.innerHTML).toBe('<p>A</p><h1>Fixed!</h1><p>B</p>');  expect(container.firstChild).toBe(firstP);  expect(container.firstChild.nextSibling.nextSibling).toBe(secondP);  // Verify next hot reload doesn't remount anything.  const helloNode = container.firstChild.nextSibling;  act(() => {patch(() => {  function Hello() {const [x] = React.useState('');React.useEffect(() => {}, []);x.sli  }  $RefreshReg$(Hello, 'Hello');});  });  expect(container.firstChild.nextSibling).toBe(helloNode);  expect(helloNode.textContent).toBe('Nice.');}  });  it('remounts a failed root on mount', () => {if (__DEV__) {  expect(() => {render(() => {  function Hello() {throw new Error('No');  }  $Re  }).toThrow('No');  expect(container.innerHTML).toBe('');  // A bad retry  expect(() => {patch(() => {  function Hello() {throw new Error('Not yet');  }  $RefreshReg$(Hello, 'Hello');});  }).toThrow('Not yet');  expect(container.innerHTML).toBe('');  // Perform a hot update that fixes the error.  patch(() => {function Hello() {}$RefreshReg$(Hello, 'Hello');  });  /  expect(() => {patch(() => {  function Hello() {throw new Error('No 2');  }  $RefreshReg$(Hello, 'Hello');});  }).toThrow('No 2');  expect(() => {patch(() => {  function Hello() {throw new Error('Not yet 2');  }  $RefreshReg$(Hello, 'Hello');});  }).toThrow('Not yet 2');  expect(container.innerHTML).toBe('');  patch(() => {function Hello() {  return <h1>Fixed 2!</h1>;}$RefreshReg$(Hello, 'Hello');  }  ReactDOM.unmountComponentAtNode(container);  patch(() => {function Hello() {  throw new Error('Ignored');$RefreshReg$(Hello, 'Hello');  });  expect(container.innerHTML).toBe('');  patch(() => {function Hello() {  return <h1>Ignored</h1>;}$RefreshReg$(Hello, 'Hello');  });  expect(container.innerHTML).toBe('');}  });  it('does not retry an intentionally unmounted failed root', () => {if (__DEV__) {  expect(() => {renthrow new Error('No');  }  $RefreshReg$(Hello, 'Hello');  return Hello;});  }).toThrow('No');  ReactDOM.unmountComponentAtNode(container);  // Perform a hot update that fixes the error.  patch(() => {function Hello() {  return <h1>Fixed!</h1>;}$RefreshReg$(Hello, 'Hello');  // This should stay unmounted.  expect(container.innerHTML).toBe('');}  });  it('remounts a failed root on update', () => {if (__DEV__) {  render(() => {function Hello() {  return <h1>Hi</h1>;}$RefreshReg$(Hello, 'Hello');return Hello;  });  expect(container.innerHTML).toBe('<h1>Hi</h1>');  // Perform a hot update that fails.  // This removes the root.  expect(() => {patthrow new Error('No');  }  $RefreshReg$(Hello, 'Hello');  }).toThrow('No');  expect(container.innerHTML).toBe('');  // A bad retry  expect(() => {patch(() => {  function Hello() {throw new Error('Not yet');  }  $RefreshReg$(Hello, 'Hello');});  }).toThrow('Not yet');  expect(container.innerHTML).toBe('');  // Perform a hot update that fixes the error.  patch(() => {function Hello() {  r$RefreshReg$(Hello, 'Hello');  });  // This should remount the root.  expect(container.innerHTML).toBe('<h1>Fixed!</h1>');  // Verify next hot reload doesn't remount anything.  const helloNode = container.firstChild;  p  return <h1>Nice.</h1>;}$RefreshReg$(Hello, 'Hello');  expect(container.firstChild).toBe(helloNode);  expect(helloNode.textContent).toBe('Nice.');  // Break again.  expect(() => {patch(() => {  function Hello() {  }  $RefreshReg$(Hello, 'Hello');});  expect(container.innerHTML).toBe('');  // Perform a hot update that fixes the error.  patch(() => {function Hello() {  return <h1>At last.</h1>;}$RefreshReg$(Hello, 'Hello');  });  // This should remount the root.  exp  expect(container.innerHTML).toBe('');  patch(() => {function Hello() {  return <h1>Never mind me!</h1>;}$RefreshReg$(Hello, 'Hello');  });  expect(container.innerHTML).toBe('');  // Mount a new container.  render(() => {function Hello() {}$RefreshReg$(Hello, 'Hello');return Hello;  });  expect(container.innerHTML).toBe('<h1>Hi</h1>');  // Break again.  expect(() => {patch(() => {  function Hello() {  }  $RefreshReg$(Hello, 'Hello');});  expect(container.innerHTML).toBe('');  // Check we don't attempt to reverse an intentional unmount, even after an error.  ReactDOM.unmountComponentAtNode(container);  expect(container.innerHTML).toBe('');  patch(() => {function Hello() {  return <h1>Never mind me!</h1>;}$RefreshReg$(Hello, 'Hello');  });  exp  });  it('regression test: does not get into an infinite loop', () => {if (__DEV__) {  const containerA = document.createElement('div');  const containerB = document.createElement('div');  // Initially, nothing interesting.  const RootAV1 = () => {  };  $RefreshReg$(RootAV1, 'RootA');  const RootBV1 = () => {return 'B1';  };  $RefreshReg$(RootBV1, 'RootB');  act(() => {ReactDOM.render(<RootAV1 />, containerA);ReactDOM.render(<RootBV1 />, containerB);  });  expect(containerB.innerHTML).toBe('B1');  // Then make the first root fail.  const RootAV2 = () => {throw new Error('A2!');  };  $RefreshReg$(RootAV2, 'RootA');  expect(() => ReactFreshRuntime.performReactRefresh()).toThrow('A2!');  expect(containerA.innerHTML).toBe('');  expect(containerB.innerHTML).toBe('B1');  // Then patch the first root, but make it fail in the commit phase.  // This used to trigger an infinite loop due to a list of failed roots  // being mutated while it was being iterated on.  const RootAV3 = () => {React.useLayoutEffect(() => {  throw new Error('A3!');}, []);retur  $RefreshReg$(RootAV3, 'RootA');  expect(() => ReactFreshRuntime.performReactRefresh()).toThrow('A3!');  expect(containerA.innerHTML).toBe(''return 'A4';  };  $RefreshReg$(RootAV4, 'RootA');  ReactFreshRuntime.performReactRefresh();  expect(containerA.innerHTML).toBe('A4');  expect(containerB.innerHTML).toBe('B1');}  });  it('remounts classes on every edit', () => {if (__DEV__) {  const HelloV1 = render(() => {class Hello extends React.Component {  state = {count: 0};  handleClick = () => {this.setState(prev => ({  count: prev.count + 1,}));  render() {return (  <p style={{color: 'blue'}} onClick={this.handleClick}>{this.state.count}  </p  }}// For classes, we wouldn't do this call via Babel plugin.// Instead, we'd do it at module boundaries.// Normally classes would get a different type and remount anyway,// but at module boundaries we may want to prevent propagation.// However we still want to force a remount and use latest version.$RefreshReg$(Hello, 'Hello');return Hello;  });  // Bump the state before patching.  const el = container.firstChild;  expect(el.textContent).toBe('0');  expect(el.style.color).toBe('blue');  act(() => {el.dispatchEvent(new MouseEvent  expect(el.textContent).toBe('1');  // Perform a hot update.  const HelloV2 = patch(() => {class Hello extends React.Component {  state = {count: 0};  handleClick = () => {this.setState(prev => ({  count: prev.count + 1,}));  };  render() {ret{this.state.count}  </p>);  }}$RefreshReg$(Hello, 'Hello');  });  // It should have remounted the class.  expect(container.firstChild).not.toBe(el);  const newEl = container.firstChild;  expect(newEl.textContent).toBe('0');  expect(newEl.style.color).toBe('red');  act(() => {newEl.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(newEl.textContent).toBe('1');  // Now top-level renders of both types resolve to latest.  render(() => HelloV1);  render(() => HelloV2);  expect(container.firstChild).toBe(newEl);  expect(newEl.style.color).toBe('red');  expect(newEl.textContent).toBe('1');  const HelloV3 = patch(() => {cla  handleClick = () => {this.setState(prev => ({  count: prev.count + 1,}));  render() {return (  <p style={{color: 'orange'}} onClick={this.handleClick}>{this.state.count}  </p>  }}$RefreshReg$(Hello, 'Hello');return Hello;  });  // It should have remounted the class again.  expect(container.firstChild).not.toBe(el);  c  expect(finalEl.style.color).toBe('orange');  act(() => {finalEl.dispatchEvent(new MouseEvent('click',ect(finalEl.textContent).toBe('1');  render(() => HelloV3);  render(() => HelloV2);  render(() => HelloV1);  expect(container.firstChild).toBe(finalEl);  expect(finalEl.style.color).toBe('orange');  expect(finalEl.textContent).toBe('1');}  });  it('updates refs when remounting', () => {if (__DEV__) {  const testRef = React.createRef();  render(() => {  class Hello extends React.Component {getColor() {  rrender() {  return <p />;}  }  return Hello;},{ref: testRef},  );  expect(testRef.current.getColor()).toBe('green');  patch(() => {classreturn 'orange';  }  render() {return <p />;  }}$RefreshReg$(Hello, 'Hello');  expect(testRef.current.getColor()).toBe('orange');  patch(() => {const Hello = React.forwardRef((props, ref) => {  React.useImperativeHandle(ref, () => ({getColor() {  return 'pink';},  }));  return <p />;});$RefreshReg$(Hello, 'Hello');  });ct.useImperativeHandle(ref, () => ({getColor() {  return 'yellow';},  }));  return <p />;});$RefreshReg$(Hello, 'Hello');  });  expect(testRef.current.getColor()).toBe('yellow');  patch(() => {cgetColor() {  ret  }));  return <p />;});  });  expect(testRef.current.getColor()).toBe('yellow');}  });  it('remounts on conversion from class to function and back', () => {if (__DEV__) {  const HelloV1 = render(() => {funct  return (<p style={{color: 'blue'}} onClick={() => setVal(val + 1)}>  {val}  );}$RefreshReg$(Hello, 'Hello');return Hello;  });  // Bump the state before patching.  const el = container.firstChild;  exp  act(() => {el.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(el.textContent).toBe('1');  // Perform a hot update that turclass Hello extends React.Component {  state = {count: 0};  handleClick = () => {this.setState(prev => ({  count: prev.count + 1,}));  };  render() {return (  <p style={{color: 'red'}} onClick={this.handleClick}>{this.state.count}  </p  }}$RefreshReg$(Hello, 'Hello');return Hello;  });  // It should have remounted.  expect(container.firstChild).not.toBe(el);  const newEl = container.fir  expect(newEl.style.color).toBe('red');  act(() => {newEl.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  expect(newEl.textContent).toBe('1');  // Now top-level renders of both types resolve to latest.  render(() => HelloV1);  render(() => HelloV2);  expect(container.firstChild).toBe(newEl);  expect(newEl.style.color).toBe('red');  expect(newEl.textContent).toBe('1');  // Now convert it back to a function.  const HelloV3 = patch(() => {f  return (<p style={{color: 'orange'}} onClick={() => setVal(val + 1)}>  {val}</p>  );}$RefreshReg$(Hello, 'Hello');return Hello;  });  // It should have remounted again.  expect(container.firstChild).not.toBe(el);ect(finalEl.style.color).toBe('orange');  act  });  expect(finalEl.textContent).toBe('1');  render(() => HelloV3);  render(() => HelloV2);  expect(container.firstChild).toBe(finalEl);  expect(finalEl.style.color).toBe('orange');  expect(finalEl.textContent).toBe('1');  // Now that it's a function, verify edits keep state.  patch(() => {function Hello() {  const [val, setVal] = React.useState(0);  ret  {val}</p>  );$RefreshReg$(Hello, 'Hello');return Hello;  });  expect(container.firstChild).toBe(finalEl);  expect(finalEl.style.color).toBe('purple');  expect(finalEl.textContent).toBe('1');}if (__DEV__) {  render(() => {function Child({children}) {  return <div className="Child">{children}</div>;$RefreshReg$(Child, 'Child');function Parent({children}) {  return (<div className="Parent">  <div><Child />  </div>  <div><Child />  </div></div>  );}  return (<div className="App">  <Parent />  <Cls><Parent />  </Cls>  <Indirection><Empty />  </Indirection></div>}$RefreshReg$(App, 'App');class Cls extends React.Component {  render() {return this.props.children;  }}function Indirection({children}) {  return children;}function Empty() {  return null;}$RefreshReg$(Empty, 'Empty');function Frag() {v className="Frag"><div />  </div>  <div className="Frag"><div />  </div></>  );}$RefreshReg$(Frag, 'Frag');return App;st emptyFamily = ReactFreshRuntime.getFamilyByID('Empty');  testFindHostInstancesForFamilies([pare  );  testFindHostInstancesForFamilies([childFamily],container.querySelectorAll('.Child'),  // we'll stop visual highlighting at the Parent.  testFindHostInstancesForFamilies([parentFamily, childFamily],container.querySelectorAll('.Parent'),  );  // When we can't find host nodes, use the closest parent.  testFindHostInstancesForFamilies([emptyFamily],container.querySelectorAll('.App'),  );}  });  function testFindHostInstancesForFamilies(families, expectedNodes) {const foundInstances = Array.from(  ReactFreshRuntime.findAffectedHostInstances(families),);expect(foundInstances.length).toEqual(expectedNodes.length);found});  }  it('can update multiple roots independently', () => {if (__DEV__) {  // Declare the first version.  const HelloV1 = () => {const [val, setVal] = React.useState(0);return (  <p style={{color: 'blue'}} onClick={() => setVal(val + 1)}>{val}  </p>  };  $RefreshReg$(HelloV1, 'Hello');  // Perform a hot update before any roots exist.  const HelloV2 = () => {const [val, setVal] = React.useState(0);return (  <p style={{color: 'red'}} onClick={() => setVal(val + 1)}>{val}  </p>);  };  $RefreshReg$(HelloV2, 'Hello');  Rea  const cont2 = document.createElement('div');  const cont3 = document.createElement('div');  document.body.appendChild(cont1);  document.body.appendChild(cont2);  try {ReactDOM.render(<HelloV1 id={1} />, cont1);ReactDOM.render(<HelloV2 id={2} />, cont2);ReactDOM.render(<HelloV1 id={3} />, cont3);// Expect we see the V2 color.expect(cont1.firstChild.style.color).toBe('red');expect(cont2.firstChild.style.color).toBe('red');expect(cont3.firstChild.style.color).toBe('red');expect(cont1.firstChild.textContent).toBe('0');expect(cont2.firstChild.textContent).toBe('0');expect(cont3.firstChild.textContent).toBe('0');// Bump the state for each of them.act(() => {  cont1.firstChild.dispatchEvent(new M  cont2.firstChild.dispatchEvent(new MouseEvent('click', {bubbles: true}),  );  con  );});expect(cont1.firstChild.style.color).toBe('red');expect(cont2.firstChild.style.color).toBe('red');expect(cont3.firstChild.style.color).toBe('red');expect(cont1.firstChild.textContent).toBe('1');expect(cont2.firstChild.textContent).toBe('1');expect(cont3.firstChild.textCon  const [val, setVal] = React.useState(0);  return (<p style={{color: 'green'}} onClick={() => setVal(val + 1)}>  {val}  );};$RefreshReg$(HelloV3, 'Hello');ReactFreshRuntime.performReactRefresh();// It should affect all roots.expect(cont1.firstChild.style.color).toBe('green');expect(cont2.firstChild.style.color).toBe('green');expect(cont3.firstChild.style.color).toBe('green');expect(cont1.firstChild.textContent).toBe('1');expect(cont2.firstChild.textContent).toBe('1');expect(cont3.firstChild.textContent).to// Make the first root throw and unmount on hot update.const HelloV4 = ({id}) => {  if (id === 1) {throw new Error('Oops.');  }  const [val, setVal] = React.useState(0);  return (<p style={{color: 'orange'}} onClick={() => setVal(val + 1)}>  {val}  );};$RefreshReg$(HelloV4, 'Hello');expect(() => {  ReactFreshRuntime.performReactRefresh();}).toThrow('Oops.');// Still, we expect the last root to be updated.expect(cont1.innerHTML).toBe('');expect(cont2.innerHTML).toBe('');expect(cont3.firstChild.style.color).toBe('orange');expect(cont3.firstChild.textContent).toBe('1');  } finally {document.body.removeChild(cont1);document.body.removeChild(cont2);document.body.removeChild(cont3);  }}  });  // Module runtimes can use this to decide whether  // to propagate an update up to the modules that imported it,  // or to stop at the current module because it's a component.  // This can't and doesn't need to be 100% precise.  it('can detect likely component types', () => {function useTheme() {}function Widget() {}if (__DEV__) {  expect(ReactFreshRuntime.isLikelyComponentType(false)).toBe(false);  expect(ReactFreshRuntime.isLikelyComponentType(null)).toBe(false);  expect(ReactFreshRuntime.isLikelyComponentType('foo'))  // editing modules that export plain functions won't trigger  // a proper reload because we will bottle up the update.  // So we're being somewhat conservative.  expect(ReactFreshRuntime.isLikelyComponentType(() => {})).toBe(false);  expect(ReactFreshRuntime.isLikelyComponentType(function () {})).toBe(false,  );  expect(ReactFreshRuntime.isLikelyComponentType(function lightenColor() {}),  ).toBe(false);  const loadUser = () => {};  expect(ReactFreshRuntime.isLikelyComponentType(loadUser)).toBe(false);  const useStore = () => {};  expect(ReactFreshRuntime.isLikelyComponentType(useStore)).toBe(false);  expect(ReactFreshRuntime.isLikelyComponentType(useTheme)).toBe(false);  const rogueProxy = new Proxy({},{throw new Error();  },},  );  expect(ReactFreshRuntime.isLikelyComponentType(rogueProxy)).toBe(false);  // These seem like function components.  const Button = () => {};  expect(ReactFreshRuntime.isLikelyComponentType(Button)).toBe(true);  expect(ReactFreshRuntime.isLiget(target, property) {  return target[property];},  });  const anon = (() => () => {})();  anon.displayName = 'Foo';  class Btn extends React.Component {}  class PureBtn extends React.PureComponent {}  const ProxyBtn = new Proxy(Btn, {get(target, property) {  return target[property];},  });  expect(ReactFreshRuntime.isLikelyComponentType(Btn)).toBe(true);  expect(ReactFreshRuntime.isLikelyComponentType(PureBtn)).toBe(true);  expect(ReactFreshRuntime.isLikelyComponentType(ProxyBtn)).toBe(true);  exp  createReactClass({render() {}}),),  ).toBe(true);  // These don't.  class Figure {move() {}  }  expect(ReactFreshRuntime.is  expect(ReactFreshRuntime.isLikelyComponentType(Point)).toBe(false);  // Run the same tests without Babel.  // This tests real arrow functions and classes, as implemented in Node.  // eslint-disable-next-line no-new-func  new Function('React','ReactFreshRuntime','expect','createReactClass',`expect(ReactFreshRuntime.isLikelyComponentType(() => {})).toBe(false);expect(ReactFreshRuntime.isLikelyComponentType(function() {})).toBe(false);expect(  ReactFreshRuntime.isLikelyComponentType(function lightenColor() {}),).toBe(false);const loadUser = () => {};const useStore = () => {};expect(ReactFreshRuntime.isLikelyComponentType(useStore)).toBe(false);function useTheme() {}expect(ReactFreshRuntime.isLikelyComponentType(useTheme)).toBe(false);// These seem like function components.let Button = () => {};expect(ReactFreshRuntime.isLikelyComponentType(Button)).toBe(true);function Widget() {}expect(ReactFreshRuntime.isLikelyComponentType(Widget)).toBe(true);let anon = (() => () => {})();anon.displayName = 'Foo';class Btn extends React.Component {}class PureBtn extends React.PureComponent {}expect(ReactFreshRuntime.isLikelyComponentType(Btn)).toBe(true);expect(ReactFreshRuntime.isLikelyComponentType(PureBtn)).toBe(true);expect(  ReactFreshRuntime.isLikelyComponentType(createReactClass({render() {}})),).toBe(true);// These don't.class Figure {  move() {}expect(ReactFreshRuntime.isLikelyComponentType(Figure)).toBe(false);class Point extends Figure {}expect(ReactFreshRuntime.isLikelyComponentType(Point)).toBe(false);  `,  )(global, React, ReactFreshRuntime, expect, createReactClass);}  });  it('reports updated and remounted families to the caller', () => {if (__DEV__) {  const HelloV1 = () => {const [val, setVal] = React.useState(0);  <p style={{color: 'blue'}} onClick={() => setVal(val + 1)}>{val}  </p>);  };  $RefreshReg$(HelloV1, 'Hello');  const HelloV2 = () => {const [val, setVal] = React.useState(0);return (  <p style={{color: 'red'}} onClick={() => setVal(val + 1)}>{val});  };  $RefreshReg$(HelloV2, 'Hello');  const update = ReactFreshRuntime.performReactRefresh();  expect(update.updatedFamilies.size).toBe(1);  expect(update.staleFamilies.size).toBe(0);  const family = update.updatedFamilies.values().next().value;  expect(family.current.name).toBe('HelloV2');  // For example, we can use this to print a log of what was updated.}const onCommitFiberRoot = jest.fn();const onCommitFiberUnmount = jest.fn();let idCounter = 0;const renderers = new Map();// This is a minimal shim for the global hook installed by DevTools.// The real one is in packages/react-devtools-shared/src/hook.js.global.__REACT_DEVTOOLS_GLOBAL_HOOK__ = {  renderers,  supportsFiber: true,  inject(renderer) {const id = ++idCounter;renderers.set(id, renderer);  },  onCommitFiberRoot,  onCommitFiberUnmount,};  }  // This simulates the scenario in https://github.com/facebook/react/issues/17626  it('can inject the runtimetFauxDevToolsHook();  // Load these first, as if they're coming from a CDN.  jest.resetModules();  React = require('react');  Scheduler = require('scheduler');  act = require('react-dom/test-utils').act;  internalAct = require('internal-test-utils').act;  // Important! Inject into the global hook *after* ReactDOM runs:  ReactFreshRuntime = require('react-refresh/runtime');  ReactFreshRuntime.injectIntoGlobalHook(global);  // We're verifying that we're able to track roots mounted after this point.  // The rest of this test is taken from the simplest first test case.  render(() => {function Hello() {  const [val, setVal] = React.useState(0);  return (<p style={{color: 'blue'}} onClick={() </p>  );}$RefreshReg$(Hello, 'Hello');return Hello;  });  // Bump the state before patching.  const el = container.firstChild;  expect(el.textContent).toBe('0');  expect(el.style.color).toBe('blue');  act(() => {el.dispatchEvent(new MouseEvent('click', {bubbles: true}));  });  patch(() => {function Hello() {  const [val, setVal] = React.useState(0);  return (  {val}</p>  );}$RefreshReg$(Hello, 'Hello');return Hello;  });  // Assert the state was preserved but color changed.  expect(container.firstChild).toBe(el);  expect(el.textContent).toBe('1'}  });  // This simulates the scenario in https://github.com/facebook/react/issues/20100  it('does not block DevTools when an unsupported renderer is injected', () => {if (__DEV__) {  initFauxDevToolsHook();  const onCommitFiberRoot =global.__REACT_DEVTOOLS_GLOBAL_HOOK__.onCo  jest.mock('scheduler', () => jest.requireActual('scheduler-0-13'));  jest.mock('scheduler/tracing', () =>jest.requireActual('scheduler-0-13/tracing'),  );  jest.mock('react', () => jest.requireActual('react-16-8'));  jest.mock('react-dom', () => jest.requireActual('react-dom-16-8'));  // Load React and company.  jest.resetModules();  React = require('react');  Scheduler = require('scheduler');  // Important! Inject into the global hook *after* ReactDOM runs:  ReactFreshRuntime = require('react-refresh/runtime');  ReactFreshRuntime.injectIntoGlobalHook(global);  render(() => {function Hello() {  return <div>Hi!</div>;}$RefreshReg$(Hello, 'Hello');return Hello;  });  expect(onCommitFiberRoot).toHaveBeenCalled();}  });});